{"version":3,"file":"Animation.js","sourceRoot":"","sources":["../../../../../src/.internal/core/utils/Animation.ts"],"names":[],"mappings":"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","sourcesContent":["/**\r\n * Animation module.\r\n */\r\n\r\n/**\r\n * ============================================================================\r\n * IMPORTS\r\n * ============================================================================\r\n * @hidden\r\n */\r\nimport { BaseObjectEvents, IBaseObjectEvents } from \"../Base\";\r\nimport { EventDispatcher, AMEvent } from \"../utils/EventDispatcher\";\r\nimport { SVGDefaults } from \"../defs/SVGDefaults\";\r\nimport { Disposer, IDisposer } from \"../utils/Disposer\";\r\nimport { registry } from \"../Registry\";\r\nimport { Color } from \"../utils/Color\";\r\nimport { Percent, percent } from \"../utils/Percent\";\r\nimport * as $async from \"../utils/AsyncPending\";\r\nimport * as $ease from \"../utils/Ease\";\r\nimport * as $colors from \"../utils/Colors\";\r\nimport * as $math from \"../utils/Math\";\r\nimport * as $array from \"../utils/Array\";\r\nimport * as $type from \"../utils/Type\";\r\nimport { system } from \"../System\";\r\n\r\n\r\n/**\r\n * Defines interface for animation objects.\r\n *\r\n * Should at least contain `update()` method.\r\n */\r\nexport interface IAnimationObject {\r\n\tupdate: () => void\r\n}\r\n\r\n/**\r\n * Defines interface for objects that can be animated\r\n */\r\nexport interface IAnimatable {\r\n\tanimations: Array<Animation>;\r\n}\r\n\r\n\r\nexport type IAnimationOption = Color | Percent | number | string | boolean;\r\n\r\n/**\r\n * Defines interface for animation options.\r\n */\r\nexport interface IAnimationOptions {\r\n\r\n\t/**\r\n\t * An initial value to animate from.\r\n\t *\r\n\t * If omitted, the source value will be current value.\r\n\t *\r\n\t * @type {Color | Percent | number | string | boolean}\r\n\t */\r\n\tfrom?: IAnimationOption;\r\n\r\n\t/**\r\n\t * A target value to animate from.\r\n\t *\r\n\t * @type {Color | Percent | number | string | boolean}\r\n\t */\r\n\tto: IAnimationOption;\r\n\r\n\t/**\r\n\t * Property name to animate.\r\n\t *\r\n\t * @type {string}\r\n\t */\r\n\tproperty?: any;\r\n\r\n\t/**\r\n\t * If current values should be taken from different object than the target\r\n\t * element of the animation, this property should be set to that object.\r\n\t *\r\n\t * @type {object}\r\n\t */\r\n\tchildObject?: { [index: string]: any };\r\n\r\n\t/**\r\n\t * A method/function reference that will be called to for updating the\r\n\t * property value.\r\n\t *\r\n\t * @type {function}\r\n\t */\r\n\tupdateMethod?: (progress: number, from: IAnimationOption, to: IAnimationOption) => IAnimationOption;\r\n\r\n\r\n\t/**\r\n\t * sometimes we need to pass some dummy data in animationOptions\r\n\t * @type {any}\r\n\t */\r\n\tdummyData?: any;\r\n\r\n}\r\n\r\n/**\r\n * An interface for an object defining [[Percent]] animation.\r\n */\r\nexport interface IPercentAnimationOptions extends IAnimationOptions {\r\n\r\n\t/**\r\n\t * Initial value.\r\n\t *\r\n\t * @type {Percent}\r\n\t */\r\n\tfrom?: Percent;\r\n\r\n\t/**\r\n\t * Target value.\r\n\t *\r\n\t * @type {Percent}\r\n\t */\r\n\tto: Percent;\r\n\r\n}\r\n\r\n/**\r\n * An interface for an object defining [[Color]] animation.\r\n */\r\nexport interface IColorAnimationOptions extends IAnimationOptions {\r\n\r\n\t/**\r\n\t * Initial value.\r\n\t *\r\n\t * @type {Color}\r\n\t */\r\n\tfrom?: Color;\r\n\r\n\t/**\r\n\t * Target value.\r\n\t *\r\n\t * @type {Color}\r\n\t */\r\n\tto: Color;\r\n\r\n}\r\n\r\n\r\n/**\r\n * Calls a `callback` function for the `duration` of milliseconds.\r\n *\r\n * @todo Needed?\r\n * @deprecated Not used anywhere\r\n * @ignore Exclude from docs\r\n * @param  {number}     duration  Duration (ms)\r\n * @param  {function}   callback  Callback function\r\n * @return {IDisposer}            Disposer\r\n */\r\nexport function animate(duration: number, callback: (time: number) => void): IDisposer {\r\n\tlet disposed = false;\r\n\r\n\t// TODO use performance.now() ?\r\n\tconst startTime = Date.now();\r\n\r\n\tfunction loop(now: number): void {\r\n\t\tif (!disposed) {\r\n\t\t\tconst diff = now - startTime;\r\n\r\n\t\t\tif (diff >= duration) {\r\n\t\t\t\tcallback(1);\r\n\r\n\t\t\t} else {\r\n\t\t\t\t$async.nextFrame(loop);\r\n\t\t\t\tcallback(diff / duration);\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\t$async.nextFrame(loop);\r\n\r\n\treturn new Disposer(() => {\r\n\t\tdisposed = true;\r\n\t});\r\n}\r\n\r\n\r\n/**\r\n * Defines events for [[Animation]].\r\n */\r\nexport interface IAnimationEvents extends IBaseObjectEvents {\r\n\r\n\t/**\r\n\t * Invoked when animation starts playing.\r\n\t */\r\n\tanimationstarted: {\r\n\t\tprogress: number;\r\n\t};\r\n\r\n\t/**\r\n\t * Invoked when animation finishes playing.\r\n\t */\r\n\tanimationended: {\r\n\t\tprogress: number;\r\n\t};\r\n\r\n\t/**\r\n\t * Invoked when animation makes progress.\r\n\t */\r\n\tanimationprogress: {\r\n\t\tprogress: number;\r\n\t};\r\n\r\n\t/**\r\n\t * Invoked when animation is stopped by some other process, before it had\r\n\t * a chance to finish.\r\n\t */\r\n\tanimationstopped: {\r\n\t\tprogress: number;\r\n\t};\r\n\r\n}\r\n\r\n/**\r\n * Holds the list of currently playing animations.\r\n *\r\n * @ignore Exclude from docs\r\n * @type {Array<IAnimationObject>}\r\n */\r\nexport const animations: Array<IAnimationObject> = [];\r\n\r\n\r\n/**\r\n * Returns numeric value accoring to progress between start and end values.\r\n *\r\n * @param  {number}  progress  Progress (0-1)\r\n * @param  {number}  from\r\n * @param  {number}  to\r\n * @return {number}            Value according to progress\r\n */\r\nfunction getProgressNumber(progress: number, from: number, to: number): number {\r\n\treturn from + ((to - from) * progress);\r\n}\r\n\r\n/**\r\n * Returns [[Percent]] value accoring to progress between start and end\r\n * values.\r\n *\r\n * @param  {number}   progress  Progress (0-1)\r\n * @param  {Percent}  from\r\n * @param  {Percent}  to\r\n * @return {number}             Value according to progress\r\n */\r\nfunction getProgressPercent(progress: number, from: Percent, to: Percent): Percent {\r\n\treturn new Percent(getProgressNumber(progress, from.percent, to.percent));\r\n}\r\n\r\n/**\r\n * Returns color value accoring to progress between start and end values.\r\n *\r\n * @param  {number}  progress  Progress (0-1)\r\n * @param  {Color}   from\r\n * @param  {Color}   to\r\n * @return {string}            Color according to progress\r\n */\r\nfunction getProgressColor(progress: number, from: Color, to: Color): Color {\r\n\treturn new Color($colors.interpolate(from.rgb, to.rgb, progress));\r\n}\r\n\r\n/**\r\n * [getHybridProperty description]\r\n *\r\n * @todo Description\r\n * @param  {string}     property [description]\r\n * @param  {\"pixel\" |        \"relative\"}  type [description]\r\n * @return {string}              [description]\r\n */\r\nfunction getHybridProperty(property: string, type: \"pixel\" | \"relative\"): string {\r\n\treturn type + property.charAt(0).toUpperCase() + property.substr(1);\r\n}\r\n\r\n\r\ninterface ProcessedAnimationOption {\r\n\tchildObject: any;\r\n\tproperty: any;\r\n\tupdate: (time: number) => void;\r\n}\r\n\r\nfunction processAnimationOptions<A>(\r\n\tobject: A,\r\n\tanimationOptions: IAnimationOptions[] | IAnimationOptions\r\n): Array<ProcessedAnimationOption> {\r\n\r\n\tconst processed: Array<ProcessedAnimationOption> = [];\r\n\r\n\t$array.each($array.toArray(animationOptions), (options) => {\r\n\t\tconst childObject = (options.childObject ? options.childObject : object);\r\n\r\n\t\tif (!$type.hasValue(options.from)) {\r\n\t\t\toptions.from = childObject[options.property];\r\n\r\n\t\t\tif (!$type.hasValue(options.from)) {\r\n\t\t\t\toptions.from = (<any>SVGDefaults)[options.property];\r\n\t\t\t}\r\n\r\n\t\t\t/*if (!$type.hasValue(options.from)) {\r\n\t\t\t\tthrow Error(\"Could not get initial transition value.\");\r\n\t\t\t}*/\r\n\t\t}\r\n\r\n\t\tif (options.from !== options.to) { // || options.to == (<any>object)[options.property]){ this is not good, as dataItem.value is set to final at once, and we animate workingValue\r\n\t\t\t// Use different update methods for different value types\r\n\t\t\tif ($type.isNumber(options.to)) {\r\n\t\t\t\t// Check if initial value is not Percent\r\n\t\t\t\tif (options.from instanceof Percent) {\r\n\t\t\t\t\t// It is. Let's convert it to pixel value\r\n\t\t\t\t\t// @todo Check if we can do this in a less hacky way\r\n\t\t\t\t\tlet convertedFrom: number = childObject[getHybridProperty(options.property, \"pixel\")];\r\n\r\n\t\t\t\t\t// TODO better check\r\n\t\t\t\t\tif (!isNaN(convertedFrom)) {\r\n\t\t\t\t\t\toptions.from = convertedFrom;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\r\n\t\t\t\tprocessed.push({\r\n\t\t\t\t\tchildObject: childObject,\r\n\t\t\t\t\tproperty: options.property,\r\n\t\t\t\t\tupdate: (time) => {\r\n\t\t\t\t\t\tchildObject[options.property] = getProgressNumber(time, <any>options.from, <any>options.to);\r\n\t\t\t\t\t}\r\n\t\t\t\t});\r\n\r\n\t\t\t\t// Check if maybe we have a color or percent value\r\n\t\t\t} else if (options.to instanceof Color) {\r\n\t\t\t\t// Yup - set resolved named color\r\n\t\t\t\t//options.from = $colors.stringToColor(<string>options.from);\r\n\t\t\t\tif (options.from) {\r\n\t\t\t\t\tprocessed.push({\r\n\t\t\t\t\t\tchildObject: childObject,\r\n\t\t\t\t\t\tproperty: options.property,\r\n\t\t\t\t\t\tupdate: (time) => {\r\n\t\t\t\t\t\t\tchildObject[options.property] = getProgressColor(time, <any>options.from, <any>options.to);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t});\r\n\r\n\t\t\t\t} else {\r\n\t\t\t\t\tprocessed.push({\r\n\t\t\t\t\t\tchildObject: childObject,\r\n\t\t\t\t\t\tproperty: options.property,\r\n\t\t\t\t\t\tupdate: (time) => {\r\n\t\t\t\t\t\t\tchildObject[options.property] = (time < 0.5 ? options.from : options.to);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t});\r\n\t\t\t\t}\r\n\r\n\t\t\t} else if (options.to instanceof Percent) {\r\n\t\t\t\t// Check if the initial value is maybe in pixels\r\n\t\t\t\t// TODO better check\r\n\t\t\t\tif (!isNaN(<number>options.from)) {\r\n\t\t\t\t\t// It is. Let's convert it\r\n\t\t\t\t\t// @todo Check if we can do this in a less hacky way\r\n\t\t\t\t\tlet convertedFrom: number = childObject[getHybridProperty(options.property, \"relative\")];\r\n\r\n\t\t\t\t\t// TODO better check\r\n\t\t\t\t\tif (!isNaN(convertedFrom)) {\r\n\t\t\t\t\t\toptions.from = percent(convertedFrom * 100);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\r\n\t\t\t\tprocessed.push({\r\n\t\t\t\t\tchildObject: childObject,\r\n\t\t\t\t\tproperty: options.property,\r\n\t\t\t\t\tupdate: (time) => {\r\n\t\t\t\t\t\tchildObject[options.property] = getProgressPercent(time, <any>options.from, <any>options.to);\r\n\t\t\t\t\t}\r\n\t\t\t\t});\r\n\r\n\t\t\t} else {\r\n\t\t\t\tprocessed.push({\r\n\t\t\t\t\tchildObject: childObject,\r\n\t\t\t\t\tproperty: options.property,\r\n\t\t\t\t\tupdate: (time) => {\r\n\t\t\t\t\t\tchildObject[options.property] = (time < 0.5 ? options.from : options.to);\r\n\t\t\t\t\t}\r\n\t\t\t\t});\r\n\t\t\t}\r\n\t\t}\r\n\t});\r\n\r\n\treturn processed;\r\n}\r\n\r\n\r\nexport class AnimationDisposer implements IDisposer {\r\n\tprivate _disposer: Disposer;\r\n\r\n\tconstructor(array: Array<Animation>) {\r\n\t\tthis._disposer = new Disposer(() => {\r\n\t\t\twhile (array.length !== 0) {\r\n\t\t\t\tarray[0].dispose();\r\n\t\t\t}\r\n\t\t});\r\n\t}\r\n\r\n\tisDisposed(): boolean {\r\n\t\treturn this._disposer.isDisposed();\r\n\t}\r\n\r\n\tdispose(): void {\r\n\t\tthis._disposer.dispose();\r\n\t}\r\n}\r\n\r\n\r\n/**\r\n * Animation can be used to transition certain properties on an object that\r\n * implements [[IAnimatable]] interface.\r\n *\r\n * @see {@link IAnimationEvents} for a list of available events\r\n */\r\nexport class Animation extends BaseObjectEvents implements IAnimationObject {\r\n\r\n\t/**\r\n\t * Defines available events.\r\n\t *\r\n\t * @type {IAnimationEvents}\r\n\t */\r\n\tpublic _events!: IAnimationEvents;\r\n\r\n\t/**\r\n\t * An animation target object. [[Animation]] will update properties of\r\n\t * this object.\r\n\t *\r\n\t * @type {IAnimatable}\r\n\t */\r\n\tpublic object: IAnimatable;\r\n\r\n\t/**\r\n\t * An array of animation option objects. Each animation object represent\r\n\t * one property. Animation can animate any number of properties\r\n\t * simultaneously.\r\n\t *\r\n\t * @type {IAnimationOptions[]}\r\n\t */\r\n\tpublic animationOptions: IAnimationOptions[];\r\n\r\n\t/**\r\n\t * Duration of the animation in milliseconds.\r\n\t *\r\n\t * @type {number}\r\n\t */\r\n\tpublic duration: number = 0;\r\n\r\n\t/**\r\n\t * Easing function to use.\r\n\t *\r\n\t * @see {@link Ease}\r\n\t * @type {(value: number) => number}\r\n\t */\r\n\tpublic easing: (value: number) => number = $ease.linear;\r\n\r\n\t/**\r\n\t * Contains progress of the current animation: 0 (start) to 1 (end).\r\n\t *\r\n\t * @type {number}\r\n\t */\r\n\tpublic progress: number = 0;\r\n\r\n\t/**\r\n\t * A list of options that cannot be animated. Those will be applied when\r\n\t * Animation ends.\r\n\t *\r\n\t * @type {IAnimationOptions[]}\r\n\t */\r\n\tprotected staticOptions!: IAnimationOptions[];\r\n\r\n\t/**\r\n\t * Indicated how many times animation should loop.\r\n\t *\r\n\t * @type {number}\r\n\t */\r\n\tprotected _loop: number = 0;\r\n\r\n\t/**\r\n\t * Animation is paused.\r\n\t *\r\n\t * @type {boolean}\r\n\t */\r\n\tprotected _pause: boolean = false;\r\n\r\n\t/**\r\n\t * Holds reference to timeout for delayed play.\r\n\t *\r\n\t * @type {IDisposer}\r\n\t */\r\n\tprotected _delayTimeout: IDisposer | null = null;\r\n\r\n\t/**\r\n\t * A timestamp of when animation started playing.\r\n\t *\r\n\t * @type {number}\r\n\t */\r\n\tprotected _startTime: $type.Optional<number>;\r\n\r\n\t/**\r\n\t * Elapsed time in currently playing animation.\r\n\t *\r\n\t * @type {number}\r\n\t */\r\n\tprotected _time: number = 0;\r\n\r\n\t// TODO verify that this is correct\r\n\tprotected debug(): void { }\r\n\r\n\tprotected _isFinished: boolean = false;\r\n\r\n\t/**\r\n\t * Constructor\r\n\t *\r\n\t * @param {IAnimatable}                              object            An object animation should run on\r\n\t * @param {IAnimationOptions[] | IAnimationOptions}  animationOptions  One or several (array) of animation options\r\n\t * @param {number}                                   duration          Duration (ms)\r\n\t * @param {(number) => number}                       easing            Easing function\r\n\t */\r\n\tconstructor(object: IAnimatable, animationOptions: IAnimationOptions[] | IAnimationOptions, duration: number, easing?: (value: number) => number) {\r\n\r\n\t\t// Init\r\n\t\tsuper();\r\n\t\tthis.className = \"Animation\";\r\n\r\n\t\t// Set parameters\r\n\t\tthis.object = object;\r\n\t\tthis.animationOptions = $array.toArray(animationOptions);\r\n\t\tthis.duration = duration;\r\n\t\tif (easing) {\r\n\t\t\tthis.easing = easing;\r\n\t\t}\r\n\r\n\t\t// Run check if there are already animations playing on the same properties\r\n\t\t// and stop them - the last animation takes precedence\r\n\t\t//this.stopSameAnimations();\r\n\r\n\t\t/*if ($type.hasValue(callback)) {\r\n\t\t\t// TODO don't use .call\r\n\t\t\tthis.events.on(\"animationended\", callback, object);\r\n\t\t}*/\r\n\r\n\t\t// Apply theme\r\n\t\tthis.applyTheme();\r\n\t}\r\n\r\n\t/**\r\n\t * Disposes this object, clears up after itself.\r\n\t */\r\n\tpublic dispose(): void {\r\n\t\tsuper.dispose();\r\n\t\tthis.pause();\r\n\t}\r\n\r\n\t/**\r\n\t * Delays animation start by X milliseconds.\r\n\t *\r\n\t * @param  {number}     delay  Delay (ms)\r\n\t * @return {Animation}         Animation\r\n\t */\r\n\tpublic delay(delay: number): Animation {\r\n\t\t//@todo Maybe not use `bind()`\r\n\t\tif (delay > 0) {\r\n\t\t\tthis.pause();\r\n\r\n\t\t\t// This is so that it will get disposed if `this.object` is disposed\r\n\t\t\t// TODO hacky, figure out a better way\r\n\t\t\t$array.move(this.object.animations, this);\r\n\r\n\t\t\tlet id = setTimeout(() => {\r\n\t\t\t\tthis._delayTimeout = null;\r\n\t\t\t\tthis.start();\r\n\t\t\t}, delay);\r\n\r\n\t\t\tthis._delayTimeout = new Disposer(() => {\r\n\t\t\t\tclearTimeout(id);\r\n\t\t\t});\r\n\t\t}\r\n\t\treturn this;\r\n\t}\r\n\r\n\tprivate _start() {\r\n\t\tthis._isFinished = false;\r\n\t\t// Clear delay timeout if there was one\r\n\t\tif (this._delayTimeout) {\r\n\t\t\tthis.removeDispose(this._delayTimeout);\r\n\t\t\tthis._delayTimeout = null;\r\n\t\t}\r\n\r\n\t\t// Run check if there are already animations playing on the same properties\r\n\t\t// and stop them - the last animation takes precedence\r\n\t\tthis.stopSameAnimations();\r\n\r\n\t\t// Reset counters\r\n\t\tthis._pause = false;\r\n\r\n\t\t// Register animation\r\n\t\t$array.move(animations, this);\r\n\r\n\t\t// Register this animation in object's `animations` list\r\n\t\t$array.move(this.object.animations, this);\r\n\r\n\t\tsystem.requestFrame();\r\n\t}\r\n\r\n\t/**\r\n\t * Starts animation.\r\n\t *\r\n\t * @return {Animation} Animation\r\n\t */\r\n\tpublic start(): Animation {\r\n\t\tthis._start();\r\n\t\tthis._startTime = Date.now();\r\n\t\tthis._time = 0;\r\n\t\tthis.staticOptions = [];\r\n\r\n\t\t// Process initial property values\r\n\t\tfor (let i: number = this.animationOptions.length - 1; i >= 0; i--) {\r\n\t\t\tlet options: IAnimationOptions = this.animationOptions[i];\r\n\t\t\tif (!$type.hasValue(options.from)) {\r\n\t\t\t\tif (options.childObject) {\r\n\t\t\t\t\toptions.from = options.childObject[options.property];\r\n\t\t\t\t}\r\n\t\t\t\telse {\r\n\t\t\t\t\toptions.from = (<any>this.object)[options.property];\r\n\r\n\t\t\t\t\tif (!$type.hasValue(options.from)) {\r\n\t\t\t\t\t\toptions.from = (<any>SVGDefaults)[options.property];\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\r\n\t\t\t\t/*if (!$type.hasValue(options.from)) {\r\n\t\t\t\t\tthrow Error(\"Could not get initial transition value.\");\r\n\t\t\t\t}*/\r\n\t\t\t}\r\n\r\n\t\t\tif (options.from == options.to) { // || options.to == (<any>this.object)[options.property]){ this is not good, as dataItem.value is set to final at once, and we animate workingValue\r\n\t\t\t\t$array.remove(this.animationOptions, options);\r\n\t\t\t}\r\n\t\t\telse if (!$type.hasValue(options.from)) {\r\n\t\t\t\t// Initial value is undefined, treat it as static\r\n\t\t\t\tthis.staticOptions.push(options);\r\n\t\t\t\t$array.remove(this.animationOptions, options);\r\n\t\t\t}\r\n\t\t\telse {\r\n\t\t\t\t// Use different update methods for different value types\r\n\t\t\t\tif ($type.isNumber(<number>options.to)) {\r\n\r\n\t\t\t\t\t// Numeric value\r\n\t\t\t\t\toptions.updateMethod = getProgressNumber;\r\n\r\n\t\t\t\t\t// Check if initial value is not Percent\r\n\t\t\t\t\tif (options.from instanceof Percent) {\r\n\t\t\t\t\t\t// It is. Let's convert it to pixel value\r\n\t\t\t\t\t\t// @todo Check if we can do this in a less hacky way\r\n\t\t\t\t\t\tlet convertedFrom: number = (<any>this.object)[getHybridProperty(options.property, \"pixel\")];\r\n\t\t\t\t\t\tif (!isNaN(convertedFrom)) {\r\n\t\t\t\t\t\t\toptions.from = convertedFrom;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\telse {\r\n\t\t\t\t\t// Check if maybe we have a color or percent value\r\n\t\t\t\t\tif (options.to instanceof Color) {\r\n\t\t\t\t\t\t// Yup - set resolved named color\r\n\t\t\t\t\t\t//options.from = $colors.stringToColor(<string>options.from);\r\n\t\t\t\t\t\tif (options.from) {\r\n\t\t\t\t\t\t\toptions.updateMethod = getProgressColor;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\telse {\r\n\t\t\t\t\t\t\t// Static value\r\n\t\t\t\t\t\t\tthis.staticOptions.push(options);\r\n\t\t\t\t\t\t\t$array.remove(this.animationOptions, options);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t\telse if (options.to instanceof Percent) {\r\n\t\t\t\t\t\t// Percent\r\n\t\t\t\t\t\toptions.updateMethod = getProgressPercent;\r\n\r\n\t\t\t\t\t\t// Check if the initial value is maybe in pixels\r\n\t\t\t\t\t\tif (!isNaN(<number>options.from)) {\r\n\t\t\t\t\t\t\t// It is. Let's convert it\r\n\t\t\t\t\t\t\t// @todo Check if we can do this in a less hacky way\r\n\t\t\t\t\t\t\tlet convertedFrom: number = (<any>this.object)[getHybridProperty(options.property, \"relative\")];\r\n\t\t\t\t\t\t\tif (!isNaN(convertedFrom)) {\r\n\t\t\t\t\t\t\t\toptions.from = percent(convertedFrom * 100);\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t\telse {\r\n\t\t\t\t\t\t// Static value\r\n\t\t\t\t\t\tthis.staticOptions.push(options);\r\n\t\t\t\t\t\t$array.remove(this.animationOptions, options);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t// Apply static options (just in case they were reset by previous\r\n\t\t// animation loop)\r\n\t\tthis.applyStaticOptions();\r\n\r\n\t\tif (this.events.isEnabled(\"animationstarted\")) {\r\n\t\t\tconst event: AMEvent<this, IAnimationEvents>[\"animationstarted\"] = {\r\n\t\t\t\ttype: \"animationstarted\",\r\n\t\t\t\ttarget: this,\r\n\t\t\t\tprogress: this.progress\r\n\t\t\t};\r\n\t\t\tthis.events.dispatchImmediately(\"animationstarted\", event);\r\n\t\t}\r\n\r\n\t\tthis.update();\r\n\r\n\t\t// If duration is 0, just end animation\r\n\t\tif (this.duration === 0) {\r\n\t\t\tthis.end();\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\t}\r\n\r\n\t/**\r\n\t * Sets loop count for the animation. If parameter is not a valid number the\r\n\t * animation will keep on looping indefinitely.\r\n\t *\r\n\t * @param  {number}     count  Number of times to loop animation\r\n\t * @return {Animation}         Animation\r\n\t */\r\n\tpublic loop(count?: number): Animation {\r\n\t\tif (!$type.isNumber(count)) {\r\n\t\t\tcount = Infinity;\r\n\t\t}\r\n\t\tthis._loop = count;\r\n\t\treturn this;\r\n\t}\r\n\r\n\t/**\r\n\t * Pauses animation.\r\n\t *\r\n\t * @return {Animation} Animation\r\n\t */\r\n\tpublic pause(): Animation {\r\n\t\tthis._pause = true;\r\n\r\n\t\tif (this._delayTimeout) {\r\n\t\t\tthis.removeDispose(this._delayTimeout);\r\n\t\t\tthis._delayTimeout = null;\r\n\t\t}\r\n\r\n\t\t$array.remove(animations, this);\r\n\t\t$array.remove(this.object.animations, this);\r\n\r\n\t\treturn this;\r\n\t}\r\n\r\n\t/**\r\n\t * Resumes paused animation.\r\n\t *\r\n\t * @return {Animation} Animation\r\n\t */\r\n\tpublic resume(): Animation {\r\n\t\tthis._start();\r\n\t\tthis._startTime = Date.now() - this._time;\r\n\t\treturn this;\r\n\t}\r\n\r\n\t/**\r\n\t * Jumps to animation end. If animation is set to loop, this will start\r\n\t * another round of animation from start.\r\n\t *\r\n\t * @return {Animation} Animation\r\n\t */\r\n\tpublic end(): Animation {\r\n\r\n\t\t// Pause and complete the progress\r\n\t\tif(this._loop == 0){\r\n\t\t\tthis.pause();\r\n\t\t}\r\n\t\tthis.setProgress(1);\r\n\r\n\t\t// Apply static options\r\n\t\tthis.applyStaticOptions();\r\n\r\n\t\tif (this.events.isEnabled(\"animationended\")) {\r\n\t\t\tconst event: AMEvent<this, IAnimationEvents>[\"animationended\"] = {\r\n\t\t\t\ttype: \"animationended\",\r\n\t\t\t\ttarget: this,\r\n\t\t\t\tprogress: this.progress\r\n\t\t\t};\r\n\t\t\tthis.events.dispatchImmediately(\"animationended\", event);\r\n\t\t}\r\n\r\n\t\t// Check if we should loop\r\n\t\tif (this._loop > 0) {\r\n\t\t\tthis._loop--;\r\n\t\t\tthis.start();\r\n\t\t}\r\n\t\telse {\r\n\t\t\tthis.stop();\r\n\t\t\tthis._isFinished = true;\r\n\t\t}\t\t\r\n\r\n\t\treturn this;\r\n\t}\r\n\r\n\tpublic kill(){\r\n\t\tthis.pause();\r\n\t\tthis._isFinished = true;\r\n\t}\r\n\r\n\t/**\r\n\t * Returns indicator if this animation is finished or not\r\n\t *\r\n\t * @return {boolean} Is finished?\r\n\t */\r\n\tpublic isFinished(): boolean {\r\n\t\treturn this._isFinished;\r\n\t}\r\n\r\n\t/**\r\n\t * Applies static options that can't be animated.\r\n\t */\r\n\tprotected applyStaticOptions(): void {\r\n\t\t$array.each(this.staticOptions, (options) => {\r\n\t\t\tif (options.childObject) {\r\n\t\t\t\toptions.childObject[options.property] = this.progress == 1 ? options.to : options.from;\r\n\t\t\t}\r\n\t\t\telse {\r\n\t\t\t\t(<any>this.object)[options.property] = this.progress == 1 ? options.to : options.from;\r\n\t\t\t}\r\n\t\t});\r\n\t}\r\n\r\n\t/**\r\n\t * Stops animation.\r\n\t *\r\n\t * When animation is stopped, the properties of the target object will remain\r\n\t * where they were at the moment when `stop()` was called.\r\n\t *\r\n\t * @param  {boolean}    skipEvent  Do not trigger `animationstopped` event\r\n\t * @return {Animation}             Animation\r\n\t */\r\n\tpublic stop(skipEvent?: boolean): Animation {\r\n\t\tthis.pause();\r\n\t\tif (!skipEvent) {\r\n\t\t\tif (this.events.isEnabled(\"animationstopped\")) {\r\n\t\t\t\tconst event: AMEvent<this, IAnimationEvents>[\"animationstopped\"] = {\r\n\t\t\t\t\ttype: \"animationstopped\",\r\n\t\t\t\t\ttarget: this,\r\n\t\t\t\t\tprogress: this.progress\r\n\t\t\t\t};\r\n\t\t\t\tthis.events.dispatchImmediately(\"animationstopped\", event);\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn this;\r\n\t}\r\n\r\n\t/**\r\n\t * Sets current progress and updates object's numeric and color values.\r\n\t *\r\n\t * @param {number} progress Progress (0-1)\r\n\t */\r\n\tpublic setProgress(progress: number): void {\r\n\t\tthis._time = this.duration * progress; // just in case we call this from outside\r\n\t\t$array.each(this.animationOptions, (options) => {\r\n\t\t\tif (options.updateMethod && $type.hasValue(options.from)) {\r\n\t\t\t\tlet value = options.updateMethod(progress, options.from, options.to);\r\n\r\n\t\t\t\tif (options.childObject) {\r\n\t\t\t\t\toptions.childObject[options.property] = value;\r\n\t\t\t\t}\r\n\t\t\t\telse {\r\n\t\t\t\t\t(<any>this.object)[options.property] = value;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t});\r\n\r\n\t\tthis.progress = progress;\r\n\t\tif (this.events.isEnabled(\"animationprogress\")) {\r\n\t\t\tconst event: AMEvent<this, IAnimationEvents>[\"animationprogress\"] = {\r\n\t\t\t\ttype: \"animationprogress\",\r\n\t\t\t\ttarget: this,\r\n\t\t\t\tprogress: this.progress\r\n\t\t\t};\r\n\t\t\tthis.events.dispatchImmediately(\"animationprogress\", event);\r\n\t\t}\r\n\r\n\t\tsystem.requestFrame();\r\n\t}\r\n\r\n\t/**\r\n\t * Tracks and sets progress according to time or frames.\r\n\t *\r\n\t * @ignore Exclude from docs\r\n\t * @return {Animation} Animation\r\n\t */\r\n\tpublic update(): Animation {\r\n\t\tif (!this._pause) {\r\n\r\n\t\t\tlet progress;\r\n\t\t\tthis._time = $math.fitToRange(Date.now() - this._startTime!, 0, this.duration);\r\n\t\t\tlet timeProgress = this._time / this.duration;\r\n\t\t\tprogress = this.easing(timeProgress);\r\n\t\t\tif (this.duration == 0 || !$type.isNumber(progress) || timeProgress >= 1) {\r\n\t\t\t\tprogress = 1;\r\n\t\t\t}\r\n\r\n\t\t\tthis.setProgress(progress);\r\n\r\n\t\t\tif ($math.round(this._time / this.duration, 6) == 1) {\r\n\t\t\t\tthis.end();\r\n\t\t\t}\r\n\r\n\t\t}\r\n\t\treturn this;\r\n\t}\r\n\r\n\t/**\r\n\t * Returns `true` if this animation is delayed.\r\n\t *\r\n\t * @readonly\r\n\t * @return {boolean} [description]\r\n\t */\r\n\tpublic get delayed(): boolean {\r\n\t\treturn this._delayTimeout ? true : false;\r\n\t}\r\n\r\n\t/**\r\n\t * Checks other animations currently running on the same object and removes\r\n\t * overlapping options from those other animations that are contained in\r\n\t * this animation.\r\n\t *\r\n\t * This is needed to ensure that no two confurent animations step on each\r\n\t * other's toes by trying to animate the same property.\r\n\t */\r\n\tprivate stopSameAnimations(): void {\r\n\t\t// stop animation of the same property\r\n\t\t// TODO make this more efficient\r\n\t\t// TODO don't copy the array\r\n\t\t$array.each($array.copy(this.object.animations), (animation) => {\r\n\t\t\tif (animation !== this && !animation.delayed) {\r\n\t\t\t\tconst killed: Array<IAnimationOptions> = [];\r\n\r\n\t\t\t\t$array.each(this.animationOptions, (newOptions) => {\r\n\t\t\t\t\t$array.each(animation.animationOptions, (oldOptions) => {\r\n\t\t\t\t\t\tif (newOptions.property == oldOptions.property && newOptions.childObject == oldOptions.childObject) {\r\n\t\t\t\t\t\t\tkilled.push(oldOptions);\r\n\r\n\t\t\t\t\t\t\tif (animation.animationOptions.length == 0) {\r\n\t\t\t\t\t\t\t\tanimation.kill();\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t});\r\n\t\t\t\t});\r\n\r\n\t\t\t\t$array.each(killed, (oldOptions) => {\r\n\t\t\t\t\t$array.remove(animation.animationOptions, oldOptions);\r\n\t\t\t\t});\r\n\t\t\t}\r\n\t\t});\r\n\t}\r\n}\r\n"]}